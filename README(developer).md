# Общая информация

## База данных

Я не стал менять базу данных, дабы при проверке задания не пришлось настраивать базу данных дополнительно, поэтому в качестве базы данных выступает SQLite. Также в репозиторий я прикрепил файл базы данных, дабы не пришлось лишний раз применять миграции, создавать аккаунт админа и сразу был материал для тестирования.

В текущей ветке соединены все ветки с конкретными заданиями из файла **tasks.md**.

## Запуск

Для запуска достаточно ввести виртуальные переменные EMAIL_HOST(почтовый профиль, с которого будет отправлено письмо для задания от клиента компании) и EMAIL_HOST_PASSWORD(пароль к почтовому профилю, с которого будет отправлено письмо для задания от клиента компании).

Также потребуется докачать все библиотеки, указанные в файле **requirements.txt** командой `pip install -r requirements.txt`.

Далее можно запустить приложение командой `python manage.py runserver`.

Так как в репозитории также присутствует файл базы данных, можно не создавать профиль суперпользователя. Он уже создан с **логином и паролем admin admin** аналогично.

## Докер

Для удобства я решил ввести докерфайл, который можно использовать для сборки образа приложения. Для этого достаточно указать при команде сборки аргументы для почты. Команда будет выглядеть следующим образом:
`docker build --build-arg EMAIL_HOST=(почтовый профиль) EMAIL_HOST_PASSWORD=(пароль от почтового профиля)`

Дальше созданный образ можно запустить командой `docker run`.

# Уточнения по заданиям

## Task 1. От технического специалиста компании.
Для создания робота был выбран путь **/robots/**, на который надо отправлять **POST** запрос с указанными данными робота в теле ответа. Валидация указанных данных происходит с помощью класса **RobotCreateValidator**, описанного в файле **robots/validation.py**. Так как в задании точно не было указано, как должны быть наименованы версии, у меня они наименованы в формате **D(любое число)**. Если данные не прошли валидацию, вызывается исключение, описанное в **R4C/exceptions.py**. Все кастомные исключения обрабатываются с использованием **middlewares**. Мой собственный **middleware** прописан в **R4C/middleware.py**. В случае, если запрос прошёл успешно, возвращается ответ с кодом 200 и телом ответа, где передается слово "**success**".

## Task 2. От директора компании
Для получения таблицы был выбран путь **/robots/table**, на который надо отправлять **GET** запрос без каких-либо данных. В ответ с использованием библиотеки pandas возвращается файл **robots.xlsx** с данными о роботах, созданных за последнюю неделю, сгруппированных по модели.

## Task 3. От клиента компании
Для выполнения этого задания был добавлен путь для создания заказа: **/orders/**, на который надо отправлять **POST** запрос с данными о почте пользователя и серийном слове робота. Для этого задания в модель заказа было добавлено поле **in_waiting**, дабы отслеживать, какому пользователю стоит отправлять письмо о появлении нужного ему робота в ассортименте. При создании записи о роботе в базе данных срабатывает сигнал **notification_email**, прописанный в файле **robots/signals.py**. Если серийное слово робота соответствует заказу, у которого стоит состояние **in_waiting**, пользователю присылается письмо в формате, указанном в задании.

Дабы лишний раз не усложнять тестирование задание, мною не была добавлена асинхронность с использованием **Celery**, дабы не заниматься дополнительно настройкой **Redis** сервера. 
