# Общая информация

В текущей ветке соединены все ветки с конкретными заданиями из файла **tasks.md**.
## База данных

В этой ветке СУБД заменена с sqlite на PostgreSQL.

## Запуск

Для запуска достаточно ввести виртуальные переменные: 
- **EMAIL_HOST** - почтовый профиль, с которого будет отправлено письмо для задания от клиента компании 
- **EMAIL_HOST_PASSWORD** - пароль к почтовому профилю, с которого будет отправлено письмо для задания от клиента компании
- **REDIS_HOST** - адрес сервера с запущенным Redis
- **POSTGRES_DB** - имя базы данных
- **POSTGRES_USER** - имя пользователя для базы данных
- **POSTGRES_PASSWORD** - пароль пользователя для СУБД
- **POSTGRES_HOST**- адрес сервера с базой данных

Также потребуется докачать все библиотеки, указанные в файле **requirements.txt** командой `pip install -r requirements.txt`.

Далее можно запустить приложение командой `python manage.py runserver`.

## Докер

Для удобства я решил ввести докерфайл, который можно использовать для сборки образа приложения. Для этого достаточно создать в директории с проектом файл **proj.env** с необходимыми переменными окружения и ввести следующую команду, находясь в директории проекта:
`docker-compose up`

## Celery

Для оптимизации процесса отправки писем был добавлен **Celery**, дабы пользователю не приходилось ждать отправки письма прежде чем получить ответ.

# Уточнения по заданиям

## Task 1. От технического специалиста компании.
Для создания робота был выбран путь **/robots/**, на который надо отправлять **POST** запрос с указанными данными робота в теле ответа. Валидация указанных данных происходит с помощью класса **RobotCreateValidator**, описанного в файле **robots/validation.py**. Так как в задании точно не было указано, как должны быть наименованы версии, у меня они наименованы в формате **D(любое число)**. Если данные не прошли валидацию, вызывается исключение, описанное в **R4C/exceptions.py**. Все кастомные исключения обрабатываются с использованием **middlewares**. Мой собственный **middleware** прописан в **R4C/middleware.py**. В случае, если запрос прошёл успешно, возвращается ответ с кодом 200 и телом ответа, где передается слово "**success**".

## Task 2. От директора компании
Для получения таблицы был выбран путь **/robots/table**, на который надо отправлять **GET** запрос без каких-либо данных. В ответ с использованием библиотеки pandas возвращается файл **robots.xlsx** с данными о роботах, созданных за последнюю неделю, сгруппированных по модели.

## Task 3. От клиента компании
Для выполнения этого задания был добавлен путь для создания заказа: **/orders/**, на который надо отправлять **POST** запрос с данными о почте пользователя и серийном слове робота. Для этого задания в модель заказа было добавлено поле **in_waiting**, дабы отслеживать, какому пользователю стоит отправлять письмо о появлении нужного ему робота в ассортименте. При создании записи о роботе в базе данных срабатывает сигнал **notification_email**, прописанный в файле **robots/signals.py**. Если серийное слово робота соответствует заказу, у которого стоит состояние **in_waiting**, пользователю присылается письмо в формате, указанном в задании.

